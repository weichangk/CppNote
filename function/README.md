# namespace 函数
git：https://github.com/weichangk/hellocpp/tree/master/function

## 函数原型
C++函数原型指的是函数声明的语法形式，它告诉编译器函数的名称、返回类型和参数列表。函数原型的语法形式如下：
```
return_type function_name(parameter_list);
```
其中，return_type 是函数返回值的数据类型，function_name 是函数的名称，而 parameter_list 是函数参数的列表，包括参数的数据类型和名称。例如，下面是一个简单的 C++ 函数原型的例子：
```
int sum(int a, int b);
```
这个函数的名称是 sum，它有两个 int 类型的参数 a 和 b，它的返回值类型是 int。函数原型只是告诉编译器函数的存在和形式，不需要函数体的实现。函数的实现可以在其他地方定义。

函数原型的作用是让编译器知道函数的存在和形式，这样在程序中调用函数时，编译器就可以进行参数类型检查和类型转换，以及对函数返回值的处理。函数原型还可以帮助程序员在程序中使用多个源文件时避免函数名称冲突的问题。

## 函数定义
C++函数定义是指在函数原型的基础上，为函数添加函数体实现的过程。函数定义通常包括函数头和函数体两部分。
函数头指的是函数的声明，包括函数的返回类型、函数名称和参数列表。函数头的语法形式如下：
```
return_type function_name(parameter_list)
```
函数体指的是函数的实现代码，它包含了函数要执行的操作和语句。函数体的语法形式如下：
```
{
    statement1;
    statement2;
    ...
    return expression;
}
```
下面是一个简单的 C++ 函数定义的例子：
```
int sum(int a, int b)
{
    int result = a + b;
    return result;
}
```
## 函数签名
C++函数签名指的是函数的名称、参数类型和参数个数的组合形式，它是用来区分不同函数的重要标识。函数签名是由函数的名称和参数列表中参数类型的组合构成的，不包括函数返回类型。例如，下面是两个函数的例子：
```
int sum(int a, int b);
float sum(float a, float b);
```
这两个函数都叫做 sum，但它们的参数类型和个数不同，因此它们的函数签名也是不同的。第一个函数的函数签名是 sum(int, int)，第二个函数的函数签名是 sum(float, float)。

C++编译器在编译时会通过函数签名来识别不同的函数，并为每个函数生成一个唯一的符号来进行链接。因此，在C++中，函数签名对于函数的调用和链接都是非常重要的。

需要注意的是，C++中允许函数重载，即同名函数可以有不同的参数列表，这些函数的函数签名也是不同的。

## 函数原型和函数签名的区别
C++函数原型和函数签名都描述了函数的形式，但是它们的意义和用途是不同的。

函数原型指的是函数声明的语法形式，它告诉编译器函数的名称、返回类型和参数列表。函数原型的作用是让编译器知道函数的存在和形式，以便在程序中调用函数时进行参数类型检查和类型转换，以及对函数返回值的处理。

函数签名是由函数的名称和参数列表中参数类型的组合构成的，不包括函数返回类型。函数签名用来区分不同函数的重要标识，编译器在编译时会通过函数签名来识别不同的函数，并为每个函数生成一个唯一的符号来进行链接。

因此，函数原型和函数签名都是描述函数形式的重要元素，但它们的作用和用途是不同的。函数原型用来声明函数的形式，让编译器知道函数的存在和形式，而函数签名则用来区分不同函数的重要标识，让编译器在编译时能够正确识别和链接不同的函数。

## 函数参数传递方式
在 C++ 中，有三种不同的参数传递方式：值传递、引用传递和指针传递。

1. 值传递：函数的形参是基本数据类型或对象，函数调用时，实参的值会被复制一份，传递给函数形参，函数对形参的修改不会影响实参的值。
    ```
    void changeValue(int n) {
        n = 100;
    }
    void func01() {
        int a = 10;
        changeValue(a);
        cout << a << endl; // 输出 10
    }
    ```

2. 引用传递：函数的形参是引用类型，函数调用时，实参的引用会被传递给函数形参，函数对形参的修改会影响实参的值。
    ```
    void changeValueByRef(int& n) {
        n = 100;
    }
    void func02() {
        int a = 10;
        changeValueByRef(a);
        cout << a << endl; // 输出 100
    }
    ```
3. 指针传递：函数的形参是指针类型，函数调用时，实参的地址会被传递给函数形参，函数可以通过指针修改实参的值。
    ```
    void changeValueByPtr(int* n)
    {
      *n = 100;
    }
    void func03()
    {
      int a = 10;
      changeValueByPtr(&a);
      cout << a << endl; // 输出 100
    }
    ```

需要注意的是，使用指针或引用传递参数可以避免因为拷贝大量数据而导致的性能问题。当函数的参数是复杂的对象时，建议使用引用或指针传递参数，以提高程序的效率。

## 数组做函数参数
在 C++ 中，可以将数组作为函数参数传递。C++ 支持以下三种将数组作为函数参数传递的方式：
1. 使用数组名作为形参
2. 使用指针作为形参
3. 使用数组引用作为形参
    ```
    //1.数组做函数参数 - 使用数组名作为形参
    //[] 指出 arr 是一个数组，[] 为空表示可以将任何长度的数组传递进来，arr 实际上不是数组而是指针。
    //使用数组名作为参数传递时，C++ 将数组名解释为数组第一个元素的的地址。在函数中可以通过指针的方式(arr[i] 等同 *(arr + i))访问数组元素。
    void printArray(int arr[], int size) {
        cout << arr << endl;//0x61fdd0 == &arr[0] //数组名为数组第一个元素地址
        for (int i = 0; i < size; i++) {
            cout << &arr[i] << " == " << arr + i << endl;
            cout << arr[i] << " == " << *(arr + i) << endl;
            // 0x61fdd0 == 0x61fdd0
            // 1 == 1
            // 0x61fdd4 == 0x61fdd4
            // 2 == 2
            // 0x61fdd8 == 0x61fdd8
            // 3 == 3
            // 0x61fddc == 0x61fddc
            // 4 == 4
            // 0x61fde0 == 0x61fde0
            // 5 == 5
        }
    }
    void func04()
    {
      int arr[] = {1, 2, 3, 4, 5};
      int size = sizeof(arr) / sizeof(arr[0]);
      printArray(arr, size);
    }

    //2.数组做函数参数 - 使用指针做形参
    //函数中使用指向数组首元素地址的指针来操作整个数组
    void printArray1(int* arr, int size)
    {
      cout << arr << endl;//0x61fdd0 == &arr[0] //指针指向数组首元素地址
      for (int i = 0; i < size; i++) {
          cout << &arr[i] << " == " << arr + i << endl;
          cout << arr[i] << " == " << *(arr + i) << endl;//
          // 0x61fdd0 == 0x61fdd0
          // 1 == 1
          // 0x61fdd4 == 0x61fdd4
          // 2 == 2
          // 0x61fdd8 == 0x61fdd8
          // 3 == 3
          // 0x61fddc == 0x61fddc
          // 4 == 4
          // 0x61fde0 == 0x61fde0
          // 5 == 5
      }
    }
    void func05()
    {
      int arr[] = {1, 2, 3, 4, 5};
      int size = sizeof(arr) / sizeof(arr[0]);
      printArray1(arr, size);
    }

    //3.数组做函数参数 - 使用数组引用作为形参
    //使用数组引用作为参数传递时，传递的是数组的引用（数组变量的别名），在函数中数组引用直接访问数组元素。
    //和上面的使用数组名作为形参的区别只是形参的写法形式不一样而已。
    void printArray(int (&arr)[5])
    {
      cout << arr << endl;//0x61fdd0 == &arr[0] //引用（数组名别名）为数组第一个元素地址
      for (int i = 0; i < 5; i++) {
          cout << &arr[i] << " == " << arr + i << endl;
          cout << arr[i] << " == " << *(arr + i) << endl;//
          // 0x61fdd0 == 0x61fdd0
          // 1 == 1
          // 0x61fdd4 == 0x61fdd4
          // 2 == 2
          // 0x61fdd8 == 0x61fdd8
          // 3 == 3
          // 0x61fddc == 0x61fddc
          // 4 == 4
          // 0x61fde0 == 0x61fde0
          // 5 == 5
      }
    }

    void func06()
    {
      int arr[] = {1, 2, 3, 4, 5};
      printArray(arr);
    }

    //通过上面的例子可以看出，无论 arr 是指针还是数组还是引用，表达式 arr[i] 都指的是数组的第i+1个元素
    // arr[i] == *(arr + i)
    // &arr[i] == arr + i
    //将指针（包括数组名，数组引用）+1 实际上是加上了一个与指针指向的类型的长度（字节为单位）相等的值，对指针（包括数组名）加减就是地址偏移的过程，达到通过地址操作数组的结果。
    //相比使用指针，使用数组的引用是一种更高效的方法，因为它不需要进行指针运算，也避免了指针所需的间接性。
    //无论哪种方式，都可以将数组传递给函数，并在函数中对其进行操作或修改。
    ```